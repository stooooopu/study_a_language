# WHEN
,는 쓰지 않음
```sql
CASE 컬럼 
    WHEN 조건1 THEN 값1
    WHEN 조건2 THEN 값2
    ELSE 값3 END
```
---
# NULL
아직 정의 되지 않은 값(0이나 공백과는 다름)  
NULL 값이 포함된 연산의 경우 결과값은 NULL  
### 1. Oracle :  NVL(표현식1, 표현식2) 
### 1. 　SQL   :  IFNULL(표현식1, 표현식2)  
표현식1의 값 = NULL 일때 표현식2의 값 출력  
이때 두 표현식의 데이터타입은 같아야 함
### 2. NULLIF(표현식1, 표현식2)
표현식1 = 표현식2 일때 NULL, 다르면 표현식1 리턴
### 3. COALESCE(표현식1, 표현식2 ...)
임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타냄

---
# ORDER BY
1. 기본적으로 ASC(오름차순)
- columnName, Alias, 위치 모두 사용 가능
```sql 
ORDER BY 1, 2 ,3 
```
- SELECT 한 column중 1, 2, 3 번째 순서로 오름차순
- 서로 다른 컬럼에 서로 다른 기준을 넣을 수 있음
```sql
SELECT column1, column2, ...
FROM tables
...
ORDER BY column1[ASC / DESC], column2[ASC / DESC]
```
2. Oracle NULL : 가장 __큰__ 값
3. SQL server : 가장 __작은__ 값
---
# TOP( )
테이블의 레코드 조회시 결과중 상위 몇개만 표시하기 위해 사용하는 구문  
순위 안에 동일한 값을 가진 결과가 있다면 WITH TIES 사용  
- 예제  
테이블에서 급여가 높은 2명을 내림차순으로 출력  
순위 안에 같은 급여를 받는 사원이 있으면 같이 출력
```sql
SELECT TOP(2) WITH TIES ename, sal
FROM emp
ORDER BY sal DESC

```
---
# JOIN
- PK이나 FK값의 연관에 의해 JOIN이 성립  
- 어떤 경우에는 관계가 없어도 논리적인 값들의 연관만으로 JOIN이 성립  
- 대부분 Non EQUI Join을 수행할 수 있지만, 때로 설계상의 이유로 수행이 불가능한 경우도 있음
```
inner join
서로 관계가 있는 데이터

outer join
서로 관계가 없는 데이터
```
---
# 모델링
```
특징
1. 현실세계를 일정한 형식에 맞추어 표현하는 추상화의 의미를 가질 수 있음
2. 시스템 구현을 포함한 업무분석 및 업무형상화가 목적
3. 복잡한 현실을 제한된 언어나 표기법을 통해 이해하기 쉽게 하는 단순화의 의미
4. 누구나 이해가 가능하도록 정확한 현상을 기술하는 정확화의 의미
```
```
필요한 이유
1. 업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현
2. 분석된 모델을 가지고 데이터베이스를 생성, 개발 및 데이터관리에 사용하기 위함
3. 데이터모델링 자체로서 업무의 흐름을 설명, 분석하는 부분에 의미를 가짐
```
```
유의점
1. 중복 : DB가 여러 장소에 같은 정보를 저장하지 않도록 주의
2. 비유연성 : 데의터의 정의를 데이터의 사용프로세스와 분리
3. 비일관성 : 데이터와 데이터간의 상호 연관관계에 대해 명확하게 정의
```
---
# 스키마 구조3단계
```
1. 외부 스키마
2. 개념 스키마 : 통합관점의 스키마구조를 표현
3. 내부 스키마
```
---
# ERD
```
ERD작성
엔터티 도출 -> 엔터티 배치 -> 관계 설정 -> 관계명 기술 -> 관계의 참여도 기술 -> 관계의 필수여부 기술
```
---
# 엔터티
```
1. 2개 이상의 속성 + 2개 이상의 인스턴스
2. 엔터티는 다른 엔터티와 관계가 무조건 있지만, 통계성, 코드성 엔터티는 관계를 생략할 수 있음
3. 엔터티는 한 개의 인스턴스를 가지는 것만으로도 충분한 의미를 부여할 수 있음
4. 유일한 식별자에 의해 식별이 가능해야 함
5. 업무프로세스에 의해 이용
```
```
기본 엔터티
그 업무에 원래 존재하는 정보로 타 엔터티의 부모역할
```
```
엔터티 이름
1. 협업 업무에서 사용하는 용어
2. 최대한 약어를 사용하지 않음
3. 유일한 이름 부여
4. 생성되는 의미대로 자연스럽게 부여
```
---
# 속성
```
1. 엔터티에 대해 자세하고 구체적인 정보를 나타냄
2. 하나의 엔터티 = 2개 이상의 속성
3. 하나의 인스턴스에서 속성은 하나의 속성값을 가짐
4. 속성도 집합
```
```
속성특성에 따른 분류
1. 기본 속성
2. 설계 속성
3. 파생 속성 : 데이터를 조회할 때 빠른 성능을 낼 수 있도록 원래 속성값을 계산 , 저자할 수 있도록 만듦
```
---
# 데이터 모델 개념
```
1. 도메인 : 각 엔터티 속성에 대해 어떤 유형의 값이 들어가는지 정의하는 개념
```
---
# 데이터 모델링 관계
```
관계는 존재에 의한 관계, 행위에 의한 관계로 구분
1. ERD표기법 : 존재와 행위를 구분하지 않고 단일화된 표기법 사용

관계는 연관관계, 의존관계로 구분
2. UML표기법 : 연관관계와 의존관계를 실선과 점선 표기법으로 다르게 표기
```
```
관계
존재적 관계, 행위에 의한 관계
관계의 표기법 : 관계명, 관계차수, 식별성
```
```
관계명
관계 차수 : 1:1, 1:M 등 관계의 기수성을 나타냄
관계 선택 사양
관계 정의
```
```
정의한 관계를 체크하는 사항
1. 두 엔터티 사이에 관심있는 연관규칙
2. 두 엔터티 사이에 정보의 조합 발생
3. 업무기술서, 장표에 관계연결을 가능하게하는 동사여부
4. 업무기술서, 장표에 관계연결에 대한 규칙 서술
```
---
# 식별자
```
1. 주식별자 : 타 엔터티와 참조관계를 연결할 수 있는 식별자
- 유일성 : 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분
- 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수
- 불변성 : 지정된 주식별자의 값은 자주 변하지 않는 것들
- 존재성 : 주식별자가 지정되면 반드시 값이 들어옴
2. 보조식별자 : 엔터티 내에서 구분자이나, 대표성을 가지지 못해 참조관계 연결을 못함

3. 단일식별자 : 하나의 속성으로 구성된 식별자
4. 복합식별자 : 둘 이상의 속성으로 구성된 식별자

5. 내부 식별자 : 스스로 만들어지는 식별자
6. 인조 식별자 : 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자

7. 본질식별자 : 업무에 의해 만들어지는 식별자
8. 인조식별자 : 업무적으로 만들어지지는 않았지만 인위적으로 만든 식별자
```
```
비식별자 관계
- 자식 일반속성에 포함
- 약한 종속, 독립적으로 구성

고려해야 하는 경우
1. 부모엔터티에 참조값이 없어도 자식엔터티의 인스턴스가 생성될 수 있는 경우
2. 여러개의 엔터티를 하나로 통합하면서 각각의 엔터티가 갖고 있던 여러개의 개별 관계가 통합되는 경우
3. 자식쪽 엔터티의 주식별자를 부모엔터티와는 별도로 생성하는 것이 더 유리한 경우
```
---
# 데이터 모델링
```
성능 데이터 모델링
데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

1. 데이터모델링을 할 때 정규화를 정확하게 수행
2. 데이터베이스 용량산정을 수행
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행
5. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정등 수행
6. 성능관점에서 데이터모델을 검증
```

---
# 정규화
```

```

---
# 용어정리
- 실행순서
```
FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY
```
- ALIAS : 별칭
- EQUI Join : join조건식에 '=' 을 사용
- Non-EQUI Join : join조건식에 '=' 제외하고 사용 하는 식    
- DBMS : 다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합
- 옵티마이저 : 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진